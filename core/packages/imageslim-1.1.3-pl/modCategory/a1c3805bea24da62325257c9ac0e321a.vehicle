<?php return array (
  'unique_key' => 'category',
  'preserve_keys' => false,
  'update_object' => true,
  'related_objects' => 
  array (
    'Snippets' => 
    array (
      '181a759fa319ebbbbfbce472c8b61e86' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":1,"source":0,"property_preprocess":0,"name":"imageSlim","description":"The Image Slenderizer. Documentation: https:\\/\\/github.com\\/oo12\\/imageSlim","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * imageSlim\\n * Copyright 2013 Jason Grant\\n *\\n * Documentation, bug reports, etc.\\n * https:\\/\\/github.com\\/oo12\\/imageSlim\\n *\\n * imageSlim is free software; you can redistribute it and\\/or modify it under the\\n * terms of the GNU General Public License as published by the Free Software\\n * Foundation; either version 2 of the License, or (at your option) any later\\n * version.\\n *\\n * imageSlim is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * imageSlim; if not, write to the Free Software Foundation, Inc., 59 Temple\\n * Place, Suite 330, Boston, MA 02111-1307 USA\\n *\\n * Variables\\n * ---------\\n *\\n * @var modX $modx\\n * @var input $input\\n * @var options $options\\n *\\n *\\n * Properties\\n * ----------\\n *\\n * @property float scale\\n * @property float conventThreshold\\n * @property integer maxWidth\\n * @property integer maxHeight\\n * @property string phpthumbof\\n * @property boolean fixAspect\\n * @property boolean remoteImages\\n * @property integer remoteTimeout\\n * @property integer q\\n * @property boolean useResizer\\n * @property string imgSrc\\n * @property boolean debug\\n *\\n * See the default properties for a description of each.\\n **\\/\\n\\nif (empty($input)) { return; }  \\/\\/ if we\'ve got nothing to do, it\'s quittin\' time\\n\\nif (isset($options)) {  \\/\\/ if we\'re being called as an output filter, set variables for any options\\n\\tparse_str($options);\\n}\\n\\n\\/\\/ process our properties\\n$scale = empty($scale) ? 1 : (float) $scale;\\n$convertThreshold = isset($convertThreshold) && $convertThreshold !== \'\' ? (float) $convertThreshold * 1024 : FALSE;\\n$maxWidth = isset($maxWidth) && $maxWidth !== \'\' ? (int) $maxWidth: 999999;\\n$maxHeight = isset($maxHeight) && $maxHeight !== \'\' ? (int) $maxHeight: 999999;\\n$phpthumbof = isset($phpthumbof) ? $phpthumbof : \'\';\\n$fixAspect = isset($fixAspect) ? (bool) $fixAspect : TRUE;\\n$remoteImages = isset($remoteImages) ? (bool) $remoteImages && function_exists(\'curl_init\') : FALSE;\\n$remoteTimeout = isset($remoteTimeout) ? (int) $remoteTimeout : 5;\\n$q = empty($q) ? \'\' : (int) $q;\\n$imgSrc = empty($imgSrc) ? \'src\' : $imgSrc;\\n$debug = isset($debug) ? (bool) $debug : FALSE;\\n$useResizer = isset($useResizer) ? $useResizer : $modx->getOption(\'imageslim.use_resizer\', NULL, TRUE);\\n\\n\\n$debug &&   $debugstr = \\"i m a g e S l i m  [1.1.3-pl]\\\\nimgSrc:$imgSrc  scale:$scale  convertThreshold:\\" . ($convertThreshold ? $convertThreshold \\/ 1024 . \'KB\' : \'none\') . \\"\\\\nmaxWidth:$maxWidth  maxHeight:$maxHeight  q:$q\\\\nfixAspect:$fixAspect  phpthumbof:$phpthumbof\\\\nRemote images:$remoteImages  Timeout:$remoteTimeout  cURL: \\" . (!function_exists(\'curl_init\') ? \'not \':\'\') . \\"installed\\\\n\\";\\n\\n$cachePath = MODX_ASSETS_PATH . \'components\\/imageslim\\/cache\\/\';\\n$badPath = MODX_BASE_PATH . ltrim(MODX_BASE_URL, \'\\/\');  \\/\\/ we\'ll use this later to weed out duplicate subdirs\\n$remoteDomains = FALSE;\\n$dom = new DOMDocument;\\n@$dom->loadHTML(\'<?xml encoding=\\"UTF-8\\">\' . $input);  \\/\\/ load this mother up\\n\\nforeach (array(\'iframe\', \'video\', \'audio\', \'textarea\') as $tag) {  \\/\\/ prevent certain tags from getting turned into self-closing tags by domDocument\\n\\tforeach ($dom->getElementsByTagName($tag) as $node) {\\n\\t\\t$node->appendChild($dom->createTextNode(\'\'));\\n\\t}\\n}\\n\\nforeach ($dom->getElementsByTagName(\'img\') as $node) {  \\/\\/ for all our images\\n\\t$src = $node->getAttribute($imgSrc);\\n\\t$file = $size = FALSE;\\n\\t$isRemote = preg_match(\'\\/^(?:https?:)?\\\\\\/\\\\\\/((?:.+?)\\\\.(?:.+?))\\\\\\/(.+)\\/i\', $src, $matches);  \\/\\/ check for absolute URLs\\n\\tif ($isRemote && MODX_HTTP_HOST === strtolower($matches[1])) {  \\/\\/ if it\'s the same server we\'re running on\\n\\t\\t$isRemote = FALSE;  \\/\\/ then it\'s not really remote\\n\\t\\t$src = $matches[2];  \\/\\/ we just need the path and filename\\n\\t}\\n\\tif ($isRemote) {  \\/\\/ if we\'ve got a real remote image to work with\\n\\t\\tif (!$remoteImages) {\\n\\t\\t\\t$debug &&   $debugstr .= \\"\\\\nsrc:$src\\\\n*** Remote image not allowed. Skipping ***\\\\n\\";\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t$file = $cachePath . preg_replace(\\"\\/[^\\\\w\\\\d\\\\-_\\\\.]\\/\\", \'-\', \\"{$matches[1]}-{$matches[2]}\\");\\n\\t\\tif (!file_exists($file)) {  \\/\\/ if it\'s not in our cache, go get it\\n\\t\\t\\t$debug &&   $debugstr .= \\"Retrieving $src\\\\nTarget filename: $file\\\\n\\";\\n\\t\\t\\t$fh = fopen($file, \'wb\');\\n\\t\\t\\tif (!$fh) {\\n\\t\\t\\t\\t$debug &&   $debugstr .= \\"*** Error ***  Can\'t write to cache directory $cachePath\\\\n\\";\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t$curlFail = FALSE;\\n\\t\\t\\tif ($src[0] === \'\\/\') {  \\/\\/cURL doesn\'t like protocol-relative URLs, so add http or https\\n    \\t\\t\\t$src = (empty($_SERVER[\'HTTPS\']) ? \'http:\' : \'https:\') . $src;\\n\\t\\t\\t}\\n\\t\\t\\t$ch = curl_init($src);\\n\\t\\t\\tcurl_setopt_array($ch, array(\\n\\t\\t\\t\\tCURLOPT_TIMEOUT\\t=> $remoteTimeout,\\n\\t\\t\\t\\tCURLOPT_FILE => $fh,\\n\\t\\t\\t\\tCURLOPT_FAILONERROR => TRUE\\n\\t\\t\\t));\\n\\t\\t\\tcurl_exec($ch);\\n\\t\\t\\tif (curl_errno($ch)) {\\n\\t\\t\\t\\t$debug &&   $debugstr .= \'cURL error: \' . curl_error($ch) . \\" *** Skipping ***\\\\n\\";\\n\\t\\t\\t\\t$curlFail = TRUE;\\n\\t\\t\\t}\\n\\t\\t\\tcurl_close($ch);\\n\\t\\t\\tfclose($fh);\\n\\t\\t\\tif ($curlFail) {  \\/\\/ if we didn\'t get it, skip and don\'t cache\\n\\t\\t\\t\\tunlink($file);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telseif ($debug) { $debugstr .= \\"Retrieved from cache: $file\\\\n\\";}\\n\\t}\\n\\telse {  \\/\\/ it\'s a local file\\n\\t\\t$file = MODX_BASE_PATH . rawurldecode(ltrim($src, \'\\/\'));  \\/\\/ Fix spaces and other encoded characters in the URL\\n\\t\\t$file = str_replace($badPath, MODX_BASE_PATH, $file);  \\/\\/ if MODX is in a subdir, keep this subdir name from occuring twice\\n\\t\\t$debug &&   $debugstr .= \\"\\\\nsrc:$file\\\\n\\";\\n\\t}\\n\\n\\t$size = @getimagesize($file);  \\/\\/ get the actual size and file type of the image.\\n\\tif ($size === FALSE) {  \\/\\/ weed out missing images and formats like svg\\n\\t\\t$debug && $debugstr .= \\"*** Can\'t get image size. Skipping ***\\\\n\\";\\n\\t\\tcontinue;\\n\\t}\\n\\n\\t$type = strtolower(substr($size[\'mime\'], strpos($size[\'mime\'], \'\\/\') + 1));  \\/\\/ extract the image type\\n\\t$ar = $size[0] \\/ $size[1];  \\/\\/ calculate our intrinsic aspect ratio\\n\\n\\t$w = $wCss = 0;  \\/\\/ initialize some stuff we\'ll need\\n\\t$h = $hCss = 0;\\n\\t$updateStyles = $adjustDisplaySize = FALSE;\\n\\tparse_str($phpthumbof, $opts);  \\/\\/ add in any user-specified phpthumb parameters\\n\\n\\t$styleAttr = $node->getAttribute(\'style\');  \\/\\/ check for width and height in an inline style first\\n\\tif ($styleAttr) {\\n\\t\\t$styles = array();\\n\\t\\tpreg_match_all(\'\\/([\\\\w-]+)\\\\s*:\\\\s*([^;]+)\\\\s*;?\\/\', $styleAttr, $matches, PREG_SET_ORDER);\\n\\t\\tforeach ($matches as $match) { $styles[$match[1]] = $match[2]; }  \\/\\/ bust everything out into an array\\n\\t\\tif (isset($styles[\'width\']) && stripos($styles[\'width\'], \'px\')) {  \\/\\/ if we have a width in pixels\\n\\t\\t\\tpreg_match(\'\\/\\\\d+\\/\', $styles[\'width\'], $matches);\\n\\t\\t\\t$wCss = $matches[0];  \\/\\/ get just the value\\n\\t\\t}\\n\\t\\tif (isset($styles[\'height\']) && stripos($styles[\'height\'], \'px\')) {  \\/\\/ same deal for height\\n\\t\\t\\tpreg_match(\'\\/\\\\d+\\/\', $styles[\'height\'], $matches);\\n\\t\\t\\t$hCss = $matches[0];\\n\\t\\t}\\n\\t}\\n\\t$w = $wCss ? $wCss : $node->getAttribute(\'width\');  \\/\\/ if we don\'t have a CSS width, get it from the width attribute\\n\\t$h = $hCss ? $hCss : $node->getAttribute(\'height\');\\n\\t$debug &&   $debugstr .= \\"w:$w  h:$h  realw:{$size[0]}  realh:{$size[1]}  type:$type\\\\n\\";\\n\\n\\t$aspectNeedsFix = FALSE;  \\/\\/ let\'s see if we need to fix a stretched image\\n\\tif ($fixAspect && $w && $h) {\\n\\t\\t$new_ar = $w \\/ $h;\\n\\t\\tif (abs($new_ar - $ar) > 0.01) {  \\/\\/ allow a little discrepancy, but nothing crazy\\n\\t\\t\\t$aspectNeedsFix = TRUE;\\n\\t\\t\\t$ar = $new_ar;\\n\\t\\t\\t$maxScale = min($scale, $size[0] \\/ $w, $size[1] \\/ $h);\\n\\t\\t\\tif ($maxScale >= 1) {  \\/\\/ if we\'ve got enough resolution to correct it, let\'s go ahead and set that up\\n\\t\\t\\t\\t$opts[\'w\'] = round($w * $maxScale);\\n\\t\\t\\t\\t$opts[\'h\'] = round($h * $maxScale);\\n\\t\\t\\t\\t$debug &&   $debugstr .= \\"++ Fixing aspect ratio. w:{$opts[\'w\']}  h:{$opts[\'h\']}  scale:$maxScale  zc:1\\\\n\\";\\n\\t\\t\\t}\\n\\t\\t\\telseif ($debug)  { $debugstr .= \\"!! Image stretched.  scale:$maxScale\\\\n\\"; }  \\/\\/ otherwise we might be able to if the image gets sized down below\\n\\t\\t}\\n\\t}\\n\\n\\t$heightPlay = 0;  \\/\\/ used to prevent height resizing on a 1px rounding difference\\n\\tif ($w && ($w > $maxWidth || $size[0] > $w * $scale)  ||  $size[0] > $maxWidth * $scale) {\\n\\t\\t$wMax = $scale * ($w ? ($w < $maxWidth ? $w : $maxWidth) : $maxWidth);\\n\\t\\t$wMax = $wMax > $size[0] ? $size[0] : $wMax;\\n\\t\\t$opts[\'w\'] = $wMax;\\n\\t\\t$newH = $size[1] < $wMax\\/$ar ? $size[1] : $wMax \\/ $ar;\\n\\t\\tif ($aspectNeedsFix) {\\n\\t\\t\\t$opts[\'w\'] = $wMax < $size[1]*$ar ? $wMax : $size[1] * $ar;  \\/\\/ reduce scale if we need to to fix a stretched image\\n\\t\\t\\t$opts[\'h\'] = $newH;\\n\\t\\t}\\n\\t\\t$size[1] = $newH;\\n\\t\\t$heightPlay = 1;\\n\\t\\t$debug &&   $debugstr .= \\"++(W) realw:{$opts[\'w\']}  realh:{$size[1]}\\\\n\\";\\n\\t\\tif ($maxWidth && $w > $maxWidth) {  \\/\\/ if we need to change the display sizing\\n\\t\\t\\t$w = $maxWidth;\\n\\t\\t\\t$h = round($maxWidth \\/ $ar);\\n\\t\\t\\t$adjustDisplaySize = TRUE;  \\/\\/ we\'ll set the size in a bit..\\n\\t\\t\\t$debug && $debugstr .= \\"++   w:$w  h:$h\\\\n\\";\\n\\t\\t}\\n\\t}\\n\\n\\tif ($h && ($h > $maxHeight || $size[1] - $heightPlay > $h * $scale)  ||  $size[1] - $heightPlay > $maxHeight * $scale) {\\n\\t\\t$hMax = $scale * ($h ? ($h < $maxHeight ? $h : $maxHeight) : $maxHeight);\\n\\t\\t$hMax = $hMax > $size[1] ? $size[1] : $hMax;\\n\\t\\t$opts[\'h\'] = $hMax;\\n\\t\\tif ($aspectNeedsFix)  {\\n\\t\\t\\t$opts[\'h\'] = $hMax < $size[0]\\/$ar ? $hMax : $size[0] \\/ $ar;  \\/\\/ reduce scale if we need to to fix a stretched image\\n\\t\\t\\t$opts[\'w\'] = $opts[\'h\'] * $ar;\\n\\t\\t}\\n\\t\\telse  { unset($opts[\'w\']); }  \\/\\/ forget about width, since height is our limiting dimension\\n\\t\\t$debug &&   $debugstr .= \'++(H) \' . (isset($opts[\'w\']) ? $opts[\'w\'] : \'\') . \\" realh:{$opts[\'h\']}\\\\n\\";\\n\\t\\tif ($maxHeight && $h > $maxHeight) {\\n\\t\\t\\t$h = $maxHeight;\\n\\t\\t\\t$w = round($maxHeight * $ar);\\n\\t\\t\\t$adjustDisplaySize = TRUE;\\n\\t\\t\\t$debug &&   $debugstr .= \\"++   w:$w  h:$h\\\\n\\";\\n\\t\\t}\\n\\t}\\n\\tif (isset($opts[\'w\']))  { $opts[\'w\'] = round($opts[\'w\']); }  \\/\\/ round these to integers\\n\\tif (isset($opts[\'h\']))  { $opts[\'h\'] = round($opts[\'h\']); }\\n\\n\\tif ($adjustDisplaySize) {  \\/\\/ ok, update our display size if we need do\\n\\t\\tif ($wCss) {  \\/\\/ if the width was in an inline style (and in px), use that\\n\\t\\t\\t$styles[\'width\'] = $w . \'px\';\\n\\t\\t\\t$updateStyles = TRUE;\\n\\t\\t}\\n\\t\\telse { $node->setAttribute(\'width\', $w); }\\n\\n\\t\\tif ($hCss) {  \\/\\/ same for height\\n\\t\\t\\t$styles[\'height\'] = $h . \'px\';\\n\\t\\t\\t$updateStyles = TRUE;\\n\\t\\t}\\n\\t\\telse { $node->setAttribute(\'height\', $h); }\\n\\t}\\n\\n\\tif ($convertThreshold !== FALSE && $type !== \'jpeg\') {\\n\\t\\t$fsize = filesize($file);\\n\\t\\tif ($fsize > $convertThreshold) {  \\/\\/ if we\'ve got a non-jpeg that\'s too big, convert it to jpeg\\n\\t\\t\\t$opts[\'f\'] = \'jpeg\';\\n\\t\\t\\t$debug &&   $debugstr .= \\"File size:$fsize  Threshold exceeded; converting to jpeg.\\\\n\\";\\n\\t\\t}\\n\\t}\\n\\n\\tif (!empty($opts)) {  \\/\\/ have we anything to do for this lovely image?\\n\\t\\tif ($aspectNeedsFix)  { $opts[\'zc\'] = 1; }\\n\\t\\tif (!isset($opts[\'f\'])) {  \\/\\/ if output file type isn\'t user specified...\\n\\t\\t\\t$opts[\'f\'] = ($type === \'jpeg\' ? \'jpeg\' : \'png\');  \\/\\/ if it\'s a gif or bmp let\'s just make it a png, shall we?\\n\\t\\t}\\n\\t\\tif ($q && $opts[\'f\'] === \'jpeg\')  { $opts[\'q\'] = $q; }  \\/\\/ add user-specified jpeg quality if it\'s relevant\\n\\t\\tif ($opts[\'f\'] === \'jpeg\') { $opts[\'f\'] = \'jpg\'; }  \\/\\/ workaround for phpThumbOf issue #53\\n\\t\\t$image = array(\\n\\t\\t\\t\'input\' => $file,\\n\\t\\t\\t\'useResizer\' => $useResizer\\n\\t\\t);\\n\\t\\t$option_str = \'\';\\n\\t\\tforeach ($opts as $k => $v)  {  \\/\\/ turn our phpthumb options array back into a string\\n\\t\\t\\tif (is_array($v)) {  \\/\\/ handle any array options like fltr[]\\n\\t\\t\\t\\tforeach($v as $param) { $option_str .= $k . \\"[]=$param&\\"; }\\n\\t\\t\\t}\\n\\t\\t\\telse { $option_str .= \\"$k=$v&\\"; }\\n\\t\\t}\\n\\t\\t$image[\'options\'] = rtrim($option_str, \'&\');\\n\\t\\t$debug &&   $debugstr .= \\"phpthumbof options: {$image[\'options\']}\\\\n\\";\\n\\t\\t$node->setAttribute($imgSrc, $modx->runSnippet(\'phpthumbof\', $image));  \\/\\/ do the business and set the src\\n\\t\\tif ($updateStyles) {\\n\\t\\t\\t$style = \'\';\\n\\t\\t\\tforeach($styles as $k => $v) { $style .= \\"$k:$v;\\"; }  \\/\\/ turn $styles array into an inline style string\\n\\t\\t\\t$node->setAttribute(\'style\', $style);\\n\\t\\t}\\n\\t}\\n\\telseif ($isRemote) {  \\/\\/ remote image but doesn\'t need any changes\\n\\t\\t$node->setAttribute($imgSrc, str_replace(MODX_ASSETS_PATH, MODX_ASSETS_URL, $file));  \\/\\/ use the locally cached version since we\'ve already got it\\n\\t}\\n}\\n\\n$output = str_replace(\'&#13;\', \'\', substr($dom->saveXML($dom->documentElement), 12, -14) );  \\/\\/ strip off the <body> tags and CR characters that DOM adds (?)\\n$debug &&   $output = \\"<!--\\\\n$debugstr-->\\\\n$output\\";\\nreturn $output;","locked":0,"properties":"a:11:{s:9:\\"fixAspect\\";a:7:{s:4:\\"name\\";s:9:\\"fixAspect\\";s:4:\\"desc\\";s:22:\\"prop_is.fixAspect_desc\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:1;s:7:\\"lexicon\\";s:17:\\"imageslim:default\\";s:4:\\"area\\";s:10:\\"Dimensions\\";}s:9:\\"maxHeight\\";a:7:{s:4:\\"name\\";s:9:\\"maxHeight\\";s:4:\\"desc\\";s:22:\\"prop_is.maxHeight_desc\\";s:4:\\"type\\";s:7:\\"integer\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"imageslim:default\\";s:4:\\"area\\";s:10:\\"Dimensions\\";}s:8:\\"maxWidth\\";a:7:{s:4:\\"name\\";s:8:\\"maxWidth\\";s:4:\\"desc\\";s:21:\\"prop_is.maxWidth_desc\\";s:4:\\"type\\";s:7:\\"integer\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"imageslim:default\\";s:4:\\"area\\";s:10:\\"Dimensions\\";}s:5:\\"scale\\";a:7:{s:4:\\"name\\";s:5:\\"scale\\";s:4:\\"desc\\";s:18:\\"prop_is.scale_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"1\\";s:7:\\"lexicon\\";s:17:\\"imageslim:default\\";s:4:\\"area\\";s:10:\\"Dimensions\\";}s:12:\\"remoteImages\\";a:7:{s:4:\\"name\\";s:12:\\"remoteImages\\";s:4:\\"desc\\";s:25:\\"prop_is.remoteImages_desc\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";s:17:\\"imageslim:default\\";s:4:\\"area\\";s:13:\\"Remote Images\\";}s:13:\\"remoteTimeout\\";a:7:{s:4:\\"name\\";s:13:\\"remoteTimeout\\";s:4:\\"desc\\";s:26:\\"prop_is.remoteTimeout_desc\\";s:4:\\"type\\";s:7:\\"integer\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"5\\";s:7:\\"lexicon\\";s:17:\\"imageslim:default\\";s:4:\\"area\\";s:13:\\"Remote Images\\";}s:16:\\"convertThreshold\\";a:7:{s:4:\\"name\\";s:16:\\"convertThreshold\\";s:4:\\"desc\\";s:29:\\"prop_is.convertThreshold_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"imageslim:default\\";s:4:\\"area\\";s:0:\\"\\";}s:10:\\"phpthumbof\\";a:7:{s:4:\\"name\\";s:10:\\"phpthumbof\\";s:4:\\"desc\\";s:23:\\"prop_is.phpthumbof_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"imageslim:default\\";s:4:\\"area\\";s:0:\\"\\";}s:1:\\"q\\";a:7:{s:4:\\"name\\";s:1:\\"q\\";s:4:\\"desc\\";s:14:\\"prop_is.q_desc\\";s:4:\\"type\\";s:7:\\"integer\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"imageslim:default\\";s:4:\\"area\\";s:0:\\"\\";}s:5:\\"debug\\";a:7:{s:4:\\"name\\";s:5:\\"debug\\";s:4:\\"desc\\";s:18:\\"prop_is.debug_desc\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";s:17:\\"imageslim:default\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"imgSrc\\";a:7:{s:4:\\"name\\";s:6:\\"imgSrc\\";s:4:\\"desc\\";s:19:\\"prop_is.imgSrc_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:3:\\"src\\";s:7:\\"lexicon\\";s:17:\\"imageslim:default\\";s:4:\\"area\\";s:0:\\"\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * imageSlim\\n * Copyright 2013 Jason Grant\\n *\\n * Documentation, bug reports, etc.\\n * https:\\/\\/github.com\\/oo12\\/imageSlim\\n *\\n * imageSlim is free software; you can redistribute it and\\/or modify it under the\\n * terms of the GNU General Public License as published by the Free Software\\n * Foundation; either version 2 of the License, or (at your option) any later\\n * version.\\n *\\n * imageSlim is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * imageSlim; if not, write to the Free Software Foundation, Inc., 59 Temple\\n * Place, Suite 330, Boston, MA 02111-1307 USA\\n *\\n * Variables\\n * ---------\\n *\\n * @var modX $modx\\n * @var input $input\\n * @var options $options\\n *\\n *\\n * Properties\\n * ----------\\n *\\n * @property float scale\\n * @property float conventThreshold\\n * @property integer maxWidth\\n * @property integer maxHeight\\n * @property string phpthumbof\\n * @property boolean fixAspect\\n * @property boolean remoteImages\\n * @property integer remoteTimeout\\n * @property integer q\\n * @property boolean useResizer\\n * @property string imgSrc\\n * @property boolean debug\\n *\\n * See the default properties for a description of each.\\n **\\/\\n\\nif (empty($input)) { return; }  \\/\\/ if we\'ve got nothing to do, it\'s quittin\' time\\n\\nif (isset($options)) {  \\/\\/ if we\'re being called as an output filter, set variables for any options\\n\\tparse_str($options);\\n}\\n\\n\\/\\/ process our properties\\n$scale = empty($scale) ? 1 : (float) $scale;\\n$convertThreshold = isset($convertThreshold) && $convertThreshold !== \'\' ? (float) $convertThreshold * 1024 : FALSE;\\n$maxWidth = isset($maxWidth) && $maxWidth !== \'\' ? (int) $maxWidth: 999999;\\n$maxHeight = isset($maxHeight) && $maxHeight !== \'\' ? (int) $maxHeight: 999999;\\n$phpthumbof = isset($phpthumbof) ? $phpthumbof : \'\';\\n$fixAspect = isset($fixAspect) ? (bool) $fixAspect : TRUE;\\n$remoteImages = isset($remoteImages) ? (bool) $remoteImages && function_exists(\'curl_init\') : FALSE;\\n$remoteTimeout = isset($remoteTimeout) ? (int) $remoteTimeout : 5;\\n$q = empty($q) ? \'\' : (int) $q;\\n$imgSrc = empty($imgSrc) ? \'src\' : $imgSrc;\\n$debug = isset($debug) ? (bool) $debug : FALSE;\\n$useResizer = isset($useResizer) ? $useResizer : $modx->getOption(\'imageslim.use_resizer\', NULL, TRUE);\\n\\n\\n$debug &&   $debugstr = \\"i m a g e S l i m  [1.1.3-pl]\\\\nimgSrc:$imgSrc  scale:$scale  convertThreshold:\\" . ($convertThreshold ? $convertThreshold \\/ 1024 . \'KB\' : \'none\') . \\"\\\\nmaxWidth:$maxWidth  maxHeight:$maxHeight  q:$q\\\\nfixAspect:$fixAspect  phpthumbof:$phpthumbof\\\\nRemote images:$remoteImages  Timeout:$remoteTimeout  cURL: \\" . (!function_exists(\'curl_init\') ? \'not \':\'\') . \\"installed\\\\n\\";\\n\\n$cachePath = MODX_ASSETS_PATH . \'components\\/imageslim\\/cache\\/\';\\n$badPath = MODX_BASE_PATH . ltrim(MODX_BASE_URL, \'\\/\');  \\/\\/ we\'ll use this later to weed out duplicate subdirs\\n$remoteDomains = FALSE;\\n$dom = new DOMDocument;\\n@$dom->loadHTML(\'<?xml encoding=\\"UTF-8\\">\' . $input);  \\/\\/ load this mother up\\n\\nforeach (array(\'iframe\', \'video\', \'audio\', \'textarea\') as $tag) {  \\/\\/ prevent certain tags from getting turned into self-closing tags by domDocument\\n\\tforeach ($dom->getElementsByTagName($tag) as $node) {\\n\\t\\t$node->appendChild($dom->createTextNode(\'\'));\\n\\t}\\n}\\n\\nforeach ($dom->getElementsByTagName(\'img\') as $node) {  \\/\\/ for all our images\\n\\t$src = $node->getAttribute($imgSrc);\\n\\t$file = $size = FALSE;\\n\\t$isRemote = preg_match(\'\\/^(?:https?:)?\\\\\\/\\\\\\/((?:.+?)\\\\.(?:.+?))\\\\\\/(.+)\\/i\', $src, $matches);  \\/\\/ check for absolute URLs\\n\\tif ($isRemote && MODX_HTTP_HOST === strtolower($matches[1])) {  \\/\\/ if it\'s the same server we\'re running on\\n\\t\\t$isRemote = FALSE;  \\/\\/ then it\'s not really remote\\n\\t\\t$src = $matches[2];  \\/\\/ we just need the path and filename\\n\\t}\\n\\tif ($isRemote) {  \\/\\/ if we\'ve got a real remote image to work with\\n\\t\\tif (!$remoteImages) {\\n\\t\\t\\t$debug &&   $debugstr .= \\"\\\\nsrc:$src\\\\n*** Remote image not allowed. Skipping ***\\\\n\\";\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t$file = $cachePath . preg_replace(\\"\\/[^\\\\w\\\\d\\\\-_\\\\.]\\/\\", \'-\', \\"{$matches[1]}-{$matches[2]}\\");\\n\\t\\tif (!file_exists($file)) {  \\/\\/ if it\'s not in our cache, go get it\\n\\t\\t\\t$debug &&   $debugstr .= \\"Retrieving $src\\\\nTarget filename: $file\\\\n\\";\\n\\t\\t\\t$fh = fopen($file, \'wb\');\\n\\t\\t\\tif (!$fh) {\\n\\t\\t\\t\\t$debug &&   $debugstr .= \\"*** Error ***  Can\'t write to cache directory $cachePath\\\\n\\";\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t$curlFail = FALSE;\\n\\t\\t\\tif ($src[0] === \'\\/\') {  \\/\\/cURL doesn\'t like protocol-relative URLs, so add http or https\\n    \\t\\t\\t$src = (empty($_SERVER[\'HTTPS\']) ? \'http:\' : \'https:\') . $src;\\n\\t\\t\\t}\\n\\t\\t\\t$ch = curl_init($src);\\n\\t\\t\\tcurl_setopt_array($ch, array(\\n\\t\\t\\t\\tCURLOPT_TIMEOUT\\t=> $remoteTimeout,\\n\\t\\t\\t\\tCURLOPT_FILE => $fh,\\n\\t\\t\\t\\tCURLOPT_FAILONERROR => TRUE\\n\\t\\t\\t));\\n\\t\\t\\tcurl_exec($ch);\\n\\t\\t\\tif (curl_errno($ch)) {\\n\\t\\t\\t\\t$debug &&   $debugstr .= \'cURL error: \' . curl_error($ch) . \\" *** Skipping ***\\\\n\\";\\n\\t\\t\\t\\t$curlFail = TRUE;\\n\\t\\t\\t}\\n\\t\\t\\tcurl_close($ch);\\n\\t\\t\\tfclose($fh);\\n\\t\\t\\tif ($curlFail) {  \\/\\/ if we didn\'t get it, skip and don\'t cache\\n\\t\\t\\t\\tunlink($file);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telseif ($debug) { $debugstr .= \\"Retrieved from cache: $file\\\\n\\";}\\n\\t}\\n\\telse {  \\/\\/ it\'s a local file\\n\\t\\t$file = MODX_BASE_PATH . rawurldecode(ltrim($src, \'\\/\'));  \\/\\/ Fix spaces and other encoded characters in the URL\\n\\t\\t$file = str_replace($badPath, MODX_BASE_PATH, $file);  \\/\\/ if MODX is in a subdir, keep this subdir name from occuring twice\\n\\t\\t$debug &&   $debugstr .= \\"\\\\nsrc:$file\\\\n\\";\\n\\t}\\n\\n\\t$size = @getimagesize($file);  \\/\\/ get the actual size and file type of the image.\\n\\tif ($size === FALSE) {  \\/\\/ weed out missing images and formats like svg\\n\\t\\t$debug && $debugstr .= \\"*** Can\'t get image size. Skipping ***\\\\n\\";\\n\\t\\tcontinue;\\n\\t}\\n\\n\\t$type = strtolower(substr($size[\'mime\'], strpos($size[\'mime\'], \'\\/\') + 1));  \\/\\/ extract the image type\\n\\t$ar = $size[0] \\/ $size[1];  \\/\\/ calculate our intrinsic aspect ratio\\n\\n\\t$w = $wCss = 0;  \\/\\/ initialize some stuff we\'ll need\\n\\t$h = $hCss = 0;\\n\\t$updateStyles = $adjustDisplaySize = FALSE;\\n\\tparse_str($phpthumbof, $opts);  \\/\\/ add in any user-specified phpthumb parameters\\n\\n\\t$styleAttr = $node->getAttribute(\'style\');  \\/\\/ check for width and height in an inline style first\\n\\tif ($styleAttr) {\\n\\t\\t$styles = array();\\n\\t\\tpreg_match_all(\'\\/([\\\\w-]+)\\\\s*:\\\\s*([^;]+)\\\\s*;?\\/\', $styleAttr, $matches, PREG_SET_ORDER);\\n\\t\\tforeach ($matches as $match) { $styles[$match[1]] = $match[2]; }  \\/\\/ bust everything out into an array\\n\\t\\tif (isset($styles[\'width\']) && stripos($styles[\'width\'], \'px\')) {  \\/\\/ if we have a width in pixels\\n\\t\\t\\tpreg_match(\'\\/\\\\d+\\/\', $styles[\'width\'], $matches);\\n\\t\\t\\t$wCss = $matches[0];  \\/\\/ get just the value\\n\\t\\t}\\n\\t\\tif (isset($styles[\'height\']) && stripos($styles[\'height\'], \'px\')) {  \\/\\/ same deal for height\\n\\t\\t\\tpreg_match(\'\\/\\\\d+\\/\', $styles[\'height\'], $matches);\\n\\t\\t\\t$hCss = $matches[0];\\n\\t\\t}\\n\\t}\\n\\t$w = $wCss ? $wCss : $node->getAttribute(\'width\');  \\/\\/ if we don\'t have a CSS width, get it from the width attribute\\n\\t$h = $hCss ? $hCss : $node->getAttribute(\'height\');\\n\\t$debug &&   $debugstr .= \\"w:$w  h:$h  realw:{$size[0]}  realh:{$size[1]}  type:$type\\\\n\\";\\n\\n\\t$aspectNeedsFix = FALSE;  \\/\\/ let\'s see if we need to fix a stretched image\\n\\tif ($fixAspect && $w && $h) {\\n\\t\\t$new_ar = $w \\/ $h;\\n\\t\\tif (abs($new_ar - $ar) > 0.01) {  \\/\\/ allow a little discrepancy, but nothing crazy\\n\\t\\t\\t$aspectNeedsFix = TRUE;\\n\\t\\t\\t$ar = $new_ar;\\n\\t\\t\\t$maxScale = min($scale, $size[0] \\/ $w, $size[1] \\/ $h);\\n\\t\\t\\tif ($maxScale >= 1) {  \\/\\/ if we\'ve got enough resolution to correct it, let\'s go ahead and set that up\\n\\t\\t\\t\\t$opts[\'w\'] = round($w * $maxScale);\\n\\t\\t\\t\\t$opts[\'h\'] = round($h * $maxScale);\\n\\t\\t\\t\\t$debug &&   $debugstr .= \\"++ Fixing aspect ratio. w:{$opts[\'w\']}  h:{$opts[\'h\']}  scale:$maxScale  zc:1\\\\n\\";\\n\\t\\t\\t}\\n\\t\\t\\telseif ($debug)  { $debugstr .= \\"!! Image stretched.  scale:$maxScale\\\\n\\"; }  \\/\\/ otherwise we might be able to if the image gets sized down below\\n\\t\\t}\\n\\t}\\n\\n\\t$heightPlay = 0;  \\/\\/ used to prevent height resizing on a 1px rounding difference\\n\\tif ($w && ($w > $maxWidth || $size[0] > $w * $scale)  ||  $size[0] > $maxWidth * $scale) {\\n\\t\\t$wMax = $scale * ($w ? ($w < $maxWidth ? $w : $maxWidth) : $maxWidth);\\n\\t\\t$wMax = $wMax > $size[0] ? $size[0] : $wMax;\\n\\t\\t$opts[\'w\'] = $wMax;\\n\\t\\t$newH = $size[1] < $wMax\\/$ar ? $size[1] : $wMax \\/ $ar;\\n\\t\\tif ($aspectNeedsFix) {\\n\\t\\t\\t$opts[\'w\'] = $wMax < $size[1]*$ar ? $wMax : $size[1] * $ar;  \\/\\/ reduce scale if we need to to fix a stretched image\\n\\t\\t\\t$opts[\'h\'] = $newH;\\n\\t\\t}\\n\\t\\t$size[1] = $newH;\\n\\t\\t$heightPlay = 1;\\n\\t\\t$debug &&   $debugstr .= \\"++(W) realw:{$opts[\'w\']}  realh:{$size[1]}\\\\n\\";\\n\\t\\tif ($maxWidth && $w > $maxWidth) {  \\/\\/ if we need to change the display sizing\\n\\t\\t\\t$w = $maxWidth;\\n\\t\\t\\t$h = round($maxWidth \\/ $ar);\\n\\t\\t\\t$adjustDisplaySize = TRUE;  \\/\\/ we\'ll set the size in a bit..\\n\\t\\t\\t$debug && $debugstr .= \\"++   w:$w  h:$h\\\\n\\";\\n\\t\\t}\\n\\t}\\n\\n\\tif ($h && ($h > $maxHeight || $size[1] - $heightPlay > $h * $scale)  ||  $size[1] - $heightPlay > $maxHeight * $scale) {\\n\\t\\t$hMax = $scale * ($h ? ($h < $maxHeight ? $h : $maxHeight) : $maxHeight);\\n\\t\\t$hMax = $hMax > $size[1] ? $size[1] : $hMax;\\n\\t\\t$opts[\'h\'] = $hMax;\\n\\t\\tif ($aspectNeedsFix)  {\\n\\t\\t\\t$opts[\'h\'] = $hMax < $size[0]\\/$ar ? $hMax : $size[0] \\/ $ar;  \\/\\/ reduce scale if we need to to fix a stretched image\\n\\t\\t\\t$opts[\'w\'] = $opts[\'h\'] * $ar;\\n\\t\\t}\\n\\t\\telse  { unset($opts[\'w\']); }  \\/\\/ forget about width, since height is our limiting dimension\\n\\t\\t$debug &&   $debugstr .= \'++(H) \' . (isset($opts[\'w\']) ? $opts[\'w\'] : \'\') . \\" realh:{$opts[\'h\']}\\\\n\\";\\n\\t\\tif ($maxHeight && $h > $maxHeight) {\\n\\t\\t\\t$h = $maxHeight;\\n\\t\\t\\t$w = round($maxHeight * $ar);\\n\\t\\t\\t$adjustDisplaySize = TRUE;\\n\\t\\t\\t$debug &&   $debugstr .= \\"++   w:$w  h:$h\\\\n\\";\\n\\t\\t}\\n\\t}\\n\\tif (isset($opts[\'w\']))  { $opts[\'w\'] = round($opts[\'w\']); }  \\/\\/ round these to integers\\n\\tif (isset($opts[\'h\']))  { $opts[\'h\'] = round($opts[\'h\']); }\\n\\n\\tif ($adjustDisplaySize) {  \\/\\/ ok, update our display size if we need do\\n\\t\\tif ($wCss) {  \\/\\/ if the width was in an inline style (and in px), use that\\n\\t\\t\\t$styles[\'width\'] = $w . \'px\';\\n\\t\\t\\t$updateStyles = TRUE;\\n\\t\\t}\\n\\t\\telse { $node->setAttribute(\'width\', $w); }\\n\\n\\t\\tif ($hCss) {  \\/\\/ same for height\\n\\t\\t\\t$styles[\'height\'] = $h . \'px\';\\n\\t\\t\\t$updateStyles = TRUE;\\n\\t\\t}\\n\\t\\telse { $node->setAttribute(\'height\', $h); }\\n\\t}\\n\\n\\tif ($convertThreshold !== FALSE && $type !== \'jpeg\') {\\n\\t\\t$fsize = filesize($file);\\n\\t\\tif ($fsize > $convertThreshold) {  \\/\\/ if we\'ve got a non-jpeg that\'s too big, convert it to jpeg\\n\\t\\t\\t$opts[\'f\'] = \'jpeg\';\\n\\t\\t\\t$debug &&   $debugstr .= \\"File size:$fsize  Threshold exceeded; converting to jpeg.\\\\n\\";\\n\\t\\t}\\n\\t}\\n\\n\\tif (!empty($opts)) {  \\/\\/ have we anything to do for this lovely image?\\n\\t\\tif ($aspectNeedsFix)  { $opts[\'zc\'] = 1; }\\n\\t\\tif (!isset($opts[\'f\'])) {  \\/\\/ if output file type isn\'t user specified...\\n\\t\\t\\t$opts[\'f\'] = ($type === \'jpeg\' ? \'jpeg\' : \'png\');  \\/\\/ if it\'s a gif or bmp let\'s just make it a png, shall we?\\n\\t\\t}\\n\\t\\tif ($q && $opts[\'f\'] === \'jpeg\')  { $opts[\'q\'] = $q; }  \\/\\/ add user-specified jpeg quality if it\'s relevant\\n\\t\\tif ($opts[\'f\'] === \'jpeg\') { $opts[\'f\'] = \'jpg\'; }  \\/\\/ workaround for phpThumbOf issue #53\\n\\t\\t$image = array(\\n\\t\\t\\t\'input\' => $file,\\n\\t\\t\\t\'useResizer\' => $useResizer\\n\\t\\t);\\n\\t\\t$option_str = \'\';\\n\\t\\tforeach ($opts as $k => $v)  {  \\/\\/ turn our phpthumb options array back into a string\\n\\t\\t\\tif (is_array($v)) {  \\/\\/ handle any array options like fltr[]\\n\\t\\t\\t\\tforeach($v as $param) { $option_str .= $k . \\"[]=$param&\\"; }\\n\\t\\t\\t}\\n\\t\\t\\telse { $option_str .= \\"$k=$v&\\"; }\\n\\t\\t}\\n\\t\\t$image[\'options\'] = rtrim($option_str, \'&\');\\n\\t\\t$debug &&   $debugstr .= \\"phpthumbof options: {$image[\'options\']}\\\\n\\";\\n\\t\\t$node->setAttribute($imgSrc, $modx->runSnippet(\'phpthumbof\', $image));  \\/\\/ do the business and set the src\\n\\t\\tif ($updateStyles) {\\n\\t\\t\\t$style = \'\';\\n\\t\\t\\tforeach($styles as $k => $v) { $style .= \\"$k:$v;\\"; }  \\/\\/ turn $styles array into an inline style string\\n\\t\\t\\t$node->setAttribute(\'style\', $style);\\n\\t\\t}\\n\\t}\\n\\telseif ($isRemote) {  \\/\\/ remote image but doesn\'t need any changes\\n\\t\\t$node->setAttribute($imgSrc, str_replace(MODX_ASSETS_PATH, MODX_ASSETS_URL, $file));  \\/\\/ use the locally cached version since we\'ve already got it\\n\\t}\\n}\\n\\n$output = str_replace(\'&#13;\', \'\', substr($dom->saveXML($dom->documentElement), 12, -14) );  \\/\\/ strip off the <body> tags and CR characters that DOM adds (?)\\n$debug &&   $output = \\"<!--\\\\n$debugstr-->\\\\n$output\\";\\nreturn $output;"}',
        'guid' => 'baff62bc55c1792361618bbbe1adf0eb',
        'native_key' => 1,
        'signature' => '265009825391c449036cf054b4f18431',
      ),
    ),
    'Plugins' => 
    array (
      '8ff524daa1cfd55bf161a9cd76a6d89d' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'related_objects' => 
        array (
          'PluginEvents' => 
          array (
            'bd27e3ad97b59bd27c18b4afad57e122' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnSiteRefresh","priority":1,"propertyset":0}',
              'guid' => '11ddec19183abadec308275f2e7823ea',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnSiteRefresh',
              ),
              'signature' => 'd5c171e43e1bab0843f62dafabb53b6a',
            ),
          ),
        ),
        'related_object_attributes' => 
        array (
          'PluginEvents' => 
          array (
            'preserve_keys' => true,
            'update_object' => false,
            'unique_key' => 
            array (
              0 => 'pluginid',
              1 => 'event',
            ),
          ),
        ),
        'class' => 'modPlugin',
        'object' => '{"id":1,"source":0,"property_preprocess":0,"name":"imageSlimCacheManager","description":"Handles remote images cache cleaning when clearing the site cache.","editor_type":0,"category":0,"cache_type":0,"plugincode":"\\/**\\n * imageSlim\\n * Copyright 2013 Jason Grant\\n *\\n * Documentation, bug reports, etc.\\n * https:\\/\\/github.com\\/oo12\\/imageSlim\\n *\\n * imageSlim is free software; you can redistribute it and\\/or modify it\\n * under the terms of the GNU General Public License as published by the Free\\n * Software Foundation; either version 2 of the License, or (at your option) any\\n * later version.\\n *\\n * imageSlim is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * imageSlim; if not, write to the Free Software Foundation, Inc., 59 Temple\\n * Place, Suite 330, Boston, MA 02111-1307 USA\\n *\\n * @package imageslim\\n *\\/\\n\\/**\\n * Handles cache management for imageSlim\\n *\\n * @var modX $modx\\n *\\n * @package imageslim\\n *\\/\\n\\nif ($modx->event->name !== \'OnSiteRefresh\') {\\n\\treturn;\\n}\\n\\n$cachePath = MODX_ASSETS_PATH . \'components\\/imageslim\\/cache\\/\';\\n\\nif (!is_writable($cachePath)) {  \\/\\/ check that the cache directory is writable\\n\\tif (!$modx->cacheManager->writeTree($cachePath)) {\\n\\t\\t$modx->log(modX::LOG_LEVEL_ERROR, \'[imageSlim] Cache path not writable: \' . $cachePath);\\n\\t\\treturn;\\n\\t}\\n}\\n\\n$cache_maxage = $modx->getOption(\'phpthumb_cache_maxage\', NULL, 30) * 86400;\\n$cache_maxsize = $modx->getOption(\'phpthumb_cache_maxsize\', NULL, 100) * 1048576;\\n$cache_maxfiles = (int) $modx->getOption(\'phpthumb_cache_maxfiles\', NULL, 10000);\\n$modx->log(modX::LOG_LEVEL_INFO, \'imageSlimCacheManager: Cleaning imageSlim remote images cache...\');\\n$modx->log(modX::LOG_LEVEL_INFO, \\":: Max Age: $cache_maxage seconds || Max Size: $cache_maxsize bytes || Max Files: $cache_maxfiles\\");\\n\\nif (!($cache_maxage || $cache_maxsize || $cache_maxfiles)) {\\n\\treturn;\\n}\\n\\n$DeletedKeys = array();\\n$AllFilesInCacheDirectory = array();\\n$dirname = rtrim(realpath($cachePath), \'\\/\\\\\\\\\');\\nif ($dirhandle = @opendir($dirname)) {\\n\\twhile (($file = readdir($dirhandle)) !== FALSE) {\\n\\t\\t$fullfilename = $dirname . DIRECTORY_SEPARATOR . $file;\\n\\t\\tif (is_file($fullfilename) && preg_match(\'\\/(jpe?g|png|gif)$\\/\', $file)) {\\n\\t\\t\\t$AllFilesInCacheDirectory[] = $fullfilename;\\n\\t\\t}\\n\\t}\\n\\tclosedir($dirhandle);\\n}\\n$totalimages = count($AllFilesInCacheDirectory);\\n$modx->log(modX::LOG_LEVEL_INFO, \\":: $totalimages image\\" . ($totalimages !== 1 ? \'s\':\'\') . \' in the cache\');\\n\\nif (empty($AllFilesInCacheDirectory)) {\\n\\treturn;\\n}\\n\\n$CacheDirOldFilesAge  = array();\\n$CacheDirOldFilesSize = array();\\nforeach ($AllFilesInCacheDirectory as $fullfilename) {\\n\\t$CacheDirOldFilesAge[$fullfilename] = @fileatime($fullfilename);\\n\\tif ($CacheDirOldFilesAge[$fullfilename] == 0) {\\n\\t\\t$CacheDirOldFilesAge[$fullfilename] = @filemtime($fullfilename);\\n\\t}\\n\\t$CacheDirOldFilesSize[$fullfilename] = @filesize($fullfilename);\\n}\\n$DeletedKeys[\'zerobyte\'] = array();\\nforeach ($CacheDirOldFilesSize as $fullfilename => $filesize) {\\n\\t\\/\\/ purge all zero-size files more than an hour old (to prevent trying to delete just-created and\\/or in-use files)\\n\\t$cutofftime = time() - 3600;\\n\\tif (($filesize == 0) && ($CacheDirOldFilesAge[$fullfilename] < $cutofftime)) {\\n\\t\\tif (@unlink($fullfilename)) {\\n\\t\\t\\t$DeletedKeys[\'zerobyte\'][] = $fullfilename;\\n\\t\\t\\tunset($CacheDirOldFilesSize[$fullfilename]);\\n\\t\\t\\tunset($CacheDirOldFilesAge[$fullfilename]);\\n\\t\\t}\\n\\t}\\n}\\n$modx->log(modX::LOG_LEVEL_INFO, \':: Purged \' . count($DeletedKeys[\'zerobyte\']) . \' zero-byte images\');\\nasort($CacheDirOldFilesAge);\\n\\nif ($cache_maxfiles) {\\n\\t$TotalCachedFiles = count($CacheDirOldFilesAge);\\n\\t$DeletedKeys[\'maxfiles\'] = array();\\n\\tforeach ($CacheDirOldFilesAge as $fullfilename => $filedate) {\\n\\t\\tif ($TotalCachedFiles > $cache_maxfiles) {\\n\\t\\t\\tif (@unlink($fullfilename)) {\\n\\t\\t\\t\\t--$TotalCachedFiles;\\n\\t\\t\\t\\t$DeletedKeys[\'maxfiles\'][] = $fullfilename;\\n\\t\\t\\t}\\n\\t\\t} else {  \\/\\/ there are few enough files to keep the rest\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\t$modx->log(modX::LOG_LEVEL_INFO, \':: Purged \' . count($DeletedKeys[\'maxfiles\']) . \\" images based on (cache_maxfiles=$cache_maxfiles)\\");\\n\\tforeach ($DeletedKeys[\'maxfiles\'] as $fullfilename) {\\n\\t\\tunset($CacheDirOldFilesAge[$fullfilename]);\\n\\t\\tunset($CacheDirOldFilesSize[$fullfilename]);\\n\\t}\\n}\\n\\nif ($cache_maxage) {\\n\\t$mindate = time() - $cache_maxage;\\n\\t$DeletedKeys[\'maxage\'] = array();\\n\\tforeach ($CacheDirOldFilesAge as $fullfilename => $filedate) {\\n\\t\\tif ($filedate) {\\n\\t\\t\\tif ($filedate < $mindate) {\\n\\t\\t\\t\\tif (@unlink($fullfilename)) {\\n\\t\\t\\t\\t\\t$DeletedKeys[\'maxage\'][] = $fullfilename;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {  \\/\\/ the rest of the files are new enough to keep\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t$modx->log(modX::LOG_LEVEL_INFO, \':: Purged \' . count($DeletedKeys[\'maxage\']) . \' images based on (cache_maxage=\'. $cache_maxage \\/ 86400 .\' days)\');\\n\\tforeach ($DeletedKeys[\'maxage\'] as $fullfilename) {\\n\\t\\tunset($CacheDirOldFilesAge[$fullfilename]);\\n\\t\\tunset($CacheDirOldFilesSize[$fullfilename]);\\n\\t}\\n}\\n\\nif ($cache_maxsize) {\\n\\t$TotalCachedFileSize = array_sum($CacheDirOldFilesSize);\\n\\t$DeletedKeys[\'maxsize\'] = array();\\n\\tforeach ($CacheDirOldFilesAge as $fullfilename => $filedate) {\\n\\t\\tif ($TotalCachedFileSize > $cache_maxsize) {\\n\\t\\t\\tif (@unlink($fullfilename)) {\\n\\t\\t\\t\\t$TotalCachedFileSize -= $CacheDirOldFilesSize[$fullfilename];\\n\\t\\t\\t\\t$DeletedKeys[\'maxsize\'][] = $fullfilename;\\n\\t\\t\\t}\\n\\t\\t} else {  \\/\\/ the total filesizes are small enough to keep the rest of the files\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\t$modx->log(modX::LOG_LEVEL_INFO, \':: Purged \' . count($DeletedKeys[\'maxsize\']) . \' images based on (cache_maxsize=\' . $cache_maxsize \\/ 1048576 . \' MB)\');\\n\\tforeach ($DeletedKeys[\'maxsize\'] as $fullfilename) {\\n\\t\\tunset($CacheDirOldFilesAge[$fullfilename]);\\n\\t\\tunset($CacheDirOldFilesSize[$fullfilename]);\\n\\t}\\n}\\n\\n$totalpurged = 0;\\nforeach ($DeletedKeys as $key => $value) {\\n\\t$totalpurged += count($value);\\n}\\n$modx->log(modX::LOG_LEVEL_INFO, \\":: Purged $totalpurged images out of $totalimages\\");","locked":0,"properties":null,"disabled":0,"moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * imageSlim\\n * Copyright 2013 Jason Grant\\n *\\n * Documentation, bug reports, etc.\\n * https:\\/\\/github.com\\/oo12\\/imageSlim\\n *\\n * imageSlim is free software; you can redistribute it and\\/or modify it\\n * under the terms of the GNU General Public License as published by the Free\\n * Software Foundation; either version 2 of the License, or (at your option) any\\n * later version.\\n *\\n * imageSlim is distributed in the hope that it will be useful, but WITHOUT ANY\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * imageSlim; if not, write to the Free Software Foundation, Inc., 59 Temple\\n * Place, Suite 330, Boston, MA 02111-1307 USA\\n *\\n * @package imageslim\\n *\\/\\n\\/**\\n * Handles cache management for imageSlim\\n *\\n * @var modX $modx\\n *\\n * @package imageslim\\n *\\/\\n\\nif ($modx->event->name !== \'OnSiteRefresh\') {\\n\\treturn;\\n}\\n\\n$cachePath = MODX_ASSETS_PATH . \'components\\/imageslim\\/cache\\/\';\\n\\nif (!is_writable($cachePath)) {  \\/\\/ check that the cache directory is writable\\n\\tif (!$modx->cacheManager->writeTree($cachePath)) {\\n\\t\\t$modx->log(modX::LOG_LEVEL_ERROR, \'[imageSlim] Cache path not writable: \' . $cachePath);\\n\\t\\treturn;\\n\\t}\\n}\\n\\n$cache_maxage = $modx->getOption(\'phpthumb_cache_maxage\', NULL, 30) * 86400;\\n$cache_maxsize = $modx->getOption(\'phpthumb_cache_maxsize\', NULL, 100) * 1048576;\\n$cache_maxfiles = (int) $modx->getOption(\'phpthumb_cache_maxfiles\', NULL, 10000);\\n$modx->log(modX::LOG_LEVEL_INFO, \'imageSlimCacheManager: Cleaning imageSlim remote images cache...\');\\n$modx->log(modX::LOG_LEVEL_INFO, \\":: Max Age: $cache_maxage seconds || Max Size: $cache_maxsize bytes || Max Files: $cache_maxfiles\\");\\n\\nif (!($cache_maxage || $cache_maxsize || $cache_maxfiles)) {\\n\\treturn;\\n}\\n\\n$DeletedKeys = array();\\n$AllFilesInCacheDirectory = array();\\n$dirname = rtrim(realpath($cachePath), \'\\/\\\\\\\\\');\\nif ($dirhandle = @opendir($dirname)) {\\n\\twhile (($file = readdir($dirhandle)) !== FALSE) {\\n\\t\\t$fullfilename = $dirname . DIRECTORY_SEPARATOR . $file;\\n\\t\\tif (is_file($fullfilename) && preg_match(\'\\/(jpe?g|png|gif)$\\/\', $file)) {\\n\\t\\t\\t$AllFilesInCacheDirectory[] = $fullfilename;\\n\\t\\t}\\n\\t}\\n\\tclosedir($dirhandle);\\n}\\n$totalimages = count($AllFilesInCacheDirectory);\\n$modx->log(modX::LOG_LEVEL_INFO, \\":: $totalimages image\\" . ($totalimages !== 1 ? \'s\':\'\') . \' in the cache\');\\n\\nif (empty($AllFilesInCacheDirectory)) {\\n\\treturn;\\n}\\n\\n$CacheDirOldFilesAge  = array();\\n$CacheDirOldFilesSize = array();\\nforeach ($AllFilesInCacheDirectory as $fullfilename) {\\n\\t$CacheDirOldFilesAge[$fullfilename] = @fileatime($fullfilename);\\n\\tif ($CacheDirOldFilesAge[$fullfilename] == 0) {\\n\\t\\t$CacheDirOldFilesAge[$fullfilename] = @filemtime($fullfilename);\\n\\t}\\n\\t$CacheDirOldFilesSize[$fullfilename] = @filesize($fullfilename);\\n}\\n$DeletedKeys[\'zerobyte\'] = array();\\nforeach ($CacheDirOldFilesSize as $fullfilename => $filesize) {\\n\\t\\/\\/ purge all zero-size files more than an hour old (to prevent trying to delete just-created and\\/or in-use files)\\n\\t$cutofftime = time() - 3600;\\n\\tif (($filesize == 0) && ($CacheDirOldFilesAge[$fullfilename] < $cutofftime)) {\\n\\t\\tif (@unlink($fullfilename)) {\\n\\t\\t\\t$DeletedKeys[\'zerobyte\'][] = $fullfilename;\\n\\t\\t\\tunset($CacheDirOldFilesSize[$fullfilename]);\\n\\t\\t\\tunset($CacheDirOldFilesAge[$fullfilename]);\\n\\t\\t}\\n\\t}\\n}\\n$modx->log(modX::LOG_LEVEL_INFO, \':: Purged \' . count($DeletedKeys[\'zerobyte\']) . \' zero-byte images\');\\nasort($CacheDirOldFilesAge);\\n\\nif ($cache_maxfiles) {\\n\\t$TotalCachedFiles = count($CacheDirOldFilesAge);\\n\\t$DeletedKeys[\'maxfiles\'] = array();\\n\\tforeach ($CacheDirOldFilesAge as $fullfilename => $filedate) {\\n\\t\\tif ($TotalCachedFiles > $cache_maxfiles) {\\n\\t\\t\\tif (@unlink($fullfilename)) {\\n\\t\\t\\t\\t--$TotalCachedFiles;\\n\\t\\t\\t\\t$DeletedKeys[\'maxfiles\'][] = $fullfilename;\\n\\t\\t\\t}\\n\\t\\t} else {  \\/\\/ there are few enough files to keep the rest\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\t$modx->log(modX::LOG_LEVEL_INFO, \':: Purged \' . count($DeletedKeys[\'maxfiles\']) . \\" images based on (cache_maxfiles=$cache_maxfiles)\\");\\n\\tforeach ($DeletedKeys[\'maxfiles\'] as $fullfilename) {\\n\\t\\tunset($CacheDirOldFilesAge[$fullfilename]);\\n\\t\\tunset($CacheDirOldFilesSize[$fullfilename]);\\n\\t}\\n}\\n\\nif ($cache_maxage) {\\n\\t$mindate = time() - $cache_maxage;\\n\\t$DeletedKeys[\'maxage\'] = array();\\n\\tforeach ($CacheDirOldFilesAge as $fullfilename => $filedate) {\\n\\t\\tif ($filedate) {\\n\\t\\t\\tif ($filedate < $mindate) {\\n\\t\\t\\t\\tif (@unlink($fullfilename)) {\\n\\t\\t\\t\\t\\t$DeletedKeys[\'maxage\'][] = $fullfilename;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {  \\/\\/ the rest of the files are new enough to keep\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t$modx->log(modX::LOG_LEVEL_INFO, \':: Purged \' . count($DeletedKeys[\'maxage\']) . \' images based on (cache_maxage=\'. $cache_maxage \\/ 86400 .\' days)\');\\n\\tforeach ($DeletedKeys[\'maxage\'] as $fullfilename) {\\n\\t\\tunset($CacheDirOldFilesAge[$fullfilename]);\\n\\t\\tunset($CacheDirOldFilesSize[$fullfilename]);\\n\\t}\\n}\\n\\nif ($cache_maxsize) {\\n\\t$TotalCachedFileSize = array_sum($CacheDirOldFilesSize);\\n\\t$DeletedKeys[\'maxsize\'] = array();\\n\\tforeach ($CacheDirOldFilesAge as $fullfilename => $filedate) {\\n\\t\\tif ($TotalCachedFileSize > $cache_maxsize) {\\n\\t\\t\\tif (@unlink($fullfilename)) {\\n\\t\\t\\t\\t$TotalCachedFileSize -= $CacheDirOldFilesSize[$fullfilename];\\n\\t\\t\\t\\t$DeletedKeys[\'maxsize\'][] = $fullfilename;\\n\\t\\t\\t}\\n\\t\\t} else {  \\/\\/ the total filesizes are small enough to keep the rest of the files\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\t$modx->log(modX::LOG_LEVEL_INFO, \':: Purged \' . count($DeletedKeys[\'maxsize\']) . \' images based on (cache_maxsize=\' . $cache_maxsize \\/ 1048576 . \' MB)\');\\n\\tforeach ($DeletedKeys[\'maxsize\'] as $fullfilename) {\\n\\t\\tunset($CacheDirOldFilesAge[$fullfilename]);\\n\\t\\tunset($CacheDirOldFilesSize[$fullfilename]);\\n\\t}\\n}\\n\\n$totalpurged = 0;\\nforeach ($DeletedKeys as $key => $value) {\\n\\t$totalpurged += count($value);\\n}\\n$modx->log(modX::LOG_LEVEL_INFO, \\":: Purged $totalpurged images out of $totalimages\\");"}',
        'guid' => '6ffbe85b4dce7e24ed4d713ae2010011',
        'native_key' => 1,
        'signature' => '613d375f34f0d939018824456f3899a5',
      ),
    ),
  ),
  'abort_install_on_vehicle_fail' => true,
  'related_object_attributes' => 
  array (
    'Snippets' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Plugins' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
      'related_objects' => true,
      'related_object_attributes' => 
      array (
        'PluginEvents' => 
        array (
          'preserve_keys' => true,
          'update_object' => false,
          'unique_key' => 
          array (
            0 => 'pluginid',
            1 => 'event',
          ),
        ),
      ),
    ),
  ),
  'namespace' => 'imageslim',
  'resolve' => 
  array (
    0 => 
    array (
      'type' => 'file',
      'body' => '{"source":"imageslim-1.1.3-pl\\/modCategory\\/a1c3805bea24da62325257c9ac0e321a\\/0\\/","target":"return MODX_CORE_PATH . \'components\\/\';","name":"imageslim"}',
    ),
    1 => 
    array (
      'type' => 'file',
      'body' => '{"source":"imageslim-1.1.3-pl\\/modCategory\\/a1c3805bea24da62325257c9ac0e321a\\/1\\/","target":"return MODX_ASSETS_PATH . \'components\\/\';","name":"imageslim"}',
    ),
  ),
  'validate' => 
  array (
    0 => 
    array (
      'type' => 'php',
      'body' => '{"source":"imageslim-1.1.3-pl\\/modCategory\\/a1c3805bea24da62325257c9ac0e321a.preinstall.script.validator","type":"php","name":"preinstall.script"}',
    ),
  ),
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => '50d4c9e3441a82d68385fb4ab18bb61f',
  'package' => 'modx',
  'class' => 'modCategory',
  'signature' => 'a1c3805bea24da62325257c9ac0e321a',
  'native_key' => 1,
  'object' => '{"id":1,"parent":0,"category":"imageSlim"}',
);